package biz.karms.sinkit.tests.core;

import biz.karms.sinkit.ejb.ArchiveServiceEJB;
import biz.karms.sinkit.ejb.CoreServiceEJB;
import biz.karms.sinkit.exception.TooOldIoCException;
import biz.karms.sinkit.ioc.IoCRecord;
import biz.karms.sinkit.ioc.IoCSourceIdType;
import biz.karms.sinkit.tests.util.IoCFactory;
import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.testng.Arquillian;
import org.jboss.shrinkwrap.api.Archive;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.importer.ZipImporter;
import org.jboss.shrinkwrap.api.spec.EnterpriseArchive;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.testng.annotations.Test;

import javax.inject.Inject;
import java.io.File;
import java.util.Calendar;
import java.util.Date;
import java.util.logging.Logger;

import static org.testng.Assert.*;


/**
 * Created by tkozel on 29.8.15.
 */
public class CoreTest extends Arquillian {

    private static final Logger LOGGER = Logger.getLogger(CoreTest.class.getName());
    private static final String TOKEN = System.getenv("SINKIT_ACCESS_TOKEN");

    @Deployment(name = "ear", testable = true)
    public static Archive<?> createTestArchive() {
        EnterpriseArchive ear = ShrinkWrap.create(ZipImporter.class, "sinkit-ear2.ear").importFrom(new File("../ear/target/sinkit-ear.ear")).as(EnterpriseArchive.class);
        ear.getAsType(JavaArchive.class, "sinkit-org.jboss.as.quickstarts.cluster.hasingleton.service.ejb.jar").addClass(CoreTest.class).addClass(IoCFactory.class);
        return ear;
    }

    @Inject
    CoreServiceEJB coreService;
    @Inject
    ArchiveServiceEJB archiveService;

    @Test(priority = 11)
    public void deduplicationTest() throws Exception {

        Calendar c = Calendar.getInstance();
        c.set(Calendar.MILLISECOND, 0);
        Date lastObservation = c.getTime();
        c.add(Calendar.MINUTE, -10);
        Date firstObservation = c.getTime();
        assertNotEquals(firstObservation, lastObservation, "Expected last and first observation times to be different, but are the same: " + firstObservation);

        IoCRecord ioc = IoCFactory.getIoCRecordAsRecieved("deduplication", "phishing", "phishing.ru", IoCSourceIdType.FQDN, firstObservation, null);
        ioc = coreService.processIoCRecord(ioc);
        assertNotNull(ioc.getDocumentId(), "Expecting documentId generated by elastic, but got null");
        assertTrue(ioc.isActive(), "Expected ioc to be active, but got inactive");
        IoCRecord iocDupl = IoCFactory.getIoCRecordAsRecieved("deduplication", "phishing", "phishing.ru", IoCSourceIdType.FQDN, lastObservation, null);
        iocDupl = coreService.processIoCRecord(iocDupl);
        assertEquals(iocDupl.getDocumentId(), ioc.getDocumentId(), "Expected documentId: " + ioc.getDocumentId() + ", but got: " + iocDupl.getDocumentId());
        assertTrue(iocDupl.isActive(), "Expected iocDupl to be active, but got inactive");
        IoCRecord iocIndexed = archiveService.findActiveIoCRecordBySourceId("phishing.ru", "phishing", "deduplication");
        assertNotNull(iocIndexed, "Expecting ioc to be found in elastic, but got null");
        assertEquals(iocIndexed.getDocumentId(), ioc.getDocumentId(), "Expexted found document id: " + ioc.getDocumentId() + ", but got: " + iocIndexed.getDocumentId());
        assertEquals(iocIndexed.getSeen().getLast(), lastObservation, "Expected seen.last: " + lastObservation + ", but got: " + iocIndexed.getSeen().getLast());
        assertEquals(iocIndexed.getTime().getObservation(), firstObservation, "Expected time.observation: " + firstObservation + ", but got " + iocIndexed.getTime().getObservation());
        assertEquals(iocIndexed.getSeen().getFirst(), firstObservation, "Expected seen.first: " + firstObservation + ", but got: " + iocIndexed.getSeen().getFirst());
    }

    @Test(priority = 12, expectedExceptions = TooOldIoCException.class)
    public void tooOldSourceTimeTest() throws Exception {

        Calendar c = Calendar.getInstance();
        c.set(Calendar.MILLISECOND, 0);
        Date timeObservation = c.getTime();
        c.add(Calendar.HOUR, -CoreServiceEJB.IOC_ACTIVE_HOURS);;
        Date timeSource = c.getTime();

        IoCRecord ioc = IoCFactory.getIoCRecordAsRecieved("tooOldIoc", "phishing", "phishing.ru", IoCSourceIdType.FQDN, timeObservation, timeSource);
        coreService.processIoCRecord(ioc);
    }

    @Test(priority = 12, expectedExceptions = TooOldIoCException.class)
    public void tooOldObservationTimeTest() throws Exception {

        Calendar c = Calendar.getInstance();
        c.set(Calendar.MILLISECOND, 0);
        c.add(Calendar.HOUR, -CoreServiceEJB.IOC_ACTIVE_HOURS);
        Date timeObservation = c.getTime();
        IoCRecord ioc = IoCFactory.getIoCRecordAsRecieved("tooOldIoc", "phishing", "phishing.ru", IoCSourceIdType.FQDN, timeObservation, null);
        coreService.processIoCRecord(ioc);
    }

    @Test(priority = 12)
    public void goodTimeTest() throws Exception {

        Calendar c = Calendar.getInstance();
        c.set(Calendar.MILLISECOND, 0);
        Date timeObservation = c.getTime();
        c.add(Calendar.HOUR, -CoreServiceEJB.IOC_ACTIVE_HOURS);
        c.add(Calendar.SECOND, 1);
        Date timeSource = c.getTime();
        Date receivedByCore = Calendar.getInstance().getTime();

        IoCRecord source = IoCFactory.getIoCRecordAsRecieved("sourceTime", "phishing", "phishing.ru", IoCSourceIdType.FQDN, timeObservation, timeSource);
        source = coreService.processIoCRecord(source);
        assertEquals(source.getSeen().getFirst(), timeSource, "Expected seen.first: " + timeSource + ", but got: " + source.getSeen().getFirst());
        assertEquals(source.getSeen().getLast(), timeSource, "Expected seen.last: " + timeSource + ", but got: " + source.getSeen().getLast());
        assertTrue(receivedByCore.before(source.getTime().getReceivedByCore()), "Expected time.receivedByCore to be after " + receivedByCore + ", but was: " + source.getTime().getReceivedByCore());

        IoCRecord observation = IoCFactory.getIoCRecordAsRecieved("observationTime", "phishing", "phishing.ru", IoCSourceIdType.FQDN, timeObservation, null);
        observation = coreService.processIoCRecord(observation);
        assertEquals(observation.getSeen().getFirst(), timeObservation, "Expected seen.first: " + timeObservation + ", but got: " + observation.getSeen().getFirst());
        assertEquals(observation.getSeen().getLast(), timeObservation, "Expected seen.last: " + timeObservation + ", but got: " + observation.getSeen().getLast());
        assertTrue(receivedByCore.before(observation.getTime().getReceivedByCore()), "Expected time.receivedByCore to be after " + receivedByCore + ", but was: " + observation.getTime().getReceivedByCore());

    }

    @Test(priority = 12)
    public void deactivationTest() throws Exception {

        Calendar c = Calendar.getInstance();
        Date deactivationTime = c.getTime();
        c.add(Calendar.HOUR, -CoreServiceEJB.IOC_ACTIVE_HOURS);
        c.add(Calendar.SECOND, 1);
        Date inactiveDate = c.getTime();
        c.add(Calendar.SECOND, 5);
        Date activeDate = c.getTime();

        IoCRecord willNotBeActive = IoCFactory.getIoCRecordAsRecieved("notActive", "phishing", "phishing.ru", IoCSourceIdType.FQDN, inactiveDate, null);
        IoCRecord willBeActive = IoCFactory.getIoCRecordAsRecieved("active", "phishing", "phishing.ru", IoCSourceIdType.FQDN, activeDate, null);

        willNotBeActive = coreService.processIoCRecord(willNotBeActive);
        willBeActive = coreService.processIoCRecord(willBeActive);

        //wait until the willNotBeActive is too old to be active
        Thread.sleep(1100);
        c = Calendar.getInstance();
        Date now = c.getTime();
        c.add(Calendar.HOUR, -CoreServiceEJB.IOC_ACTIVE_HOURS);
        Date deactivationLimit = c.getTime();
        assertTrue(deactivationLimit.after(willNotBeActive.getSeen().getLast()), "Expected seen.last to be before: " + deactivationLimit + ", but was: " + willNotBeActive.getSeen().getLast());

        int deactivated = coreService.deactivateIocs();
        assertTrue(deactivated > 0, "Expecting at least 1 deactivated IoC, but got 0");
        willNotBeActive = archiveService.getIoCRecordById(willNotBeActive.getDocumentId());
        assertFalse(willNotBeActive.isActive(), "Expected not active IoC, but was active");
        assertTrue(deactivationTime.before(willNotBeActive.getTime().getDeactivated()), "Expected time activation to be after: " + deactivationTime + ", but was: " + willNotBeActive.getTime().getDeactivated());

        willBeActive = archiveService.getIoCRecordById(willBeActive.getDocumentId());
        assertTrue(willBeActive.isActive(), "Expeced active IoC, but was inactive");
    }
}
